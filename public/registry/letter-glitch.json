{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "letter-glitch",
  "title": "Letter Glitch",
  "description": "A minimalistic letter glitch component designed with React and Tailwind CSS.",
  "author": "Reche Soares",
  "type": "registry:ui",
  "dependencies": [],
  "devDependencies": [],
  "registryDependencies": [],
  "cssVars": {
    "dark": {},
    "light": {}
  },
  "files": [
    {
      "path": "letter-glitch.tsx",
      "content": "\"use client\";\r\nimport { useRef, useEffect, useCallback } from \"react\";\r\n\r\nconst FONT_SIZE = 16;\r\nconst CHAR_WIDTH = 10;\r\nconst CHAR_HEIGHT = 20;\r\nconst CHARACTER_SET =\r\n  \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%&*()-_{}[]:;<>,.?/\";\r\nclass Particle {\r\n  x: number;\r\n  y: number;\r\n  char: string;\r\n  initialColor: string;\r\n  currentColor: string;\r\n  targetColor: string;\r\n  colorProgress: number;\r\n\r\n  constructor(\r\n    x: number,\r\n    y: number,\r\n    char: string,\r\n    color: string,\r\n    targetColor: string\r\n  ) {\r\n    this.x = x;\r\n    this.y = y;\r\n    this.char = char;\r\n    this.initialColor = color;\r\n    this.currentColor = color;\r\n    this.targetColor = targetColor;\r\n    this.colorProgress = 1.0; // Start fully at the initial color\r\n  }\r\n\r\n  // Draws the particle on the canvas\r\n  draw(ctx: CanvasRenderingContext2D) {\r\n    ctx.fillStyle = this.currentColor;\r\n    ctx.fillText(this.char, this.x, this.y);\r\n  }\r\n\r\n  // Assigns a new random character\r\n  randomizeCharacter() {\r\n    this.char = CHARACTER_SET[Math.floor(Math.random() * CHARACTER_SET.length)];\r\n  }\r\n\r\n  // Sets a new target color to transition towards\r\n  setNewTargetColor(newColor: string, smooth: boolean) {\r\n    if (!smooth) {\r\n      this.currentColor = newColor;\r\n      this.targetColor = newColor;\r\n      this.colorProgress = 1.0;\r\n    } else {\r\n      this.initialColor = this.currentColor;\r\n      this.targetColor = newColor;\r\n      this.colorProgress = 0.0;\r\n    }\r\n  }\r\n\r\n  // Updates the color transition if needed\r\n  updateColorTransition(): boolean {\r\n    if (this.colorProgress >= 1) return false;\r\n\r\n    this.colorProgress = Math.min(this.colorProgress + 0.05, 1);\r\n\r\n    const start = ColorUtils.hexToRgb(this.initialColor);\r\n    const end = ColorUtils.hexToRgb(this.targetColor);\r\n\r\n    if (start && end) {\r\n      this.currentColor = ColorUtils.interpolateRgb(\r\n        start,\r\n        end,\r\n        this.colorProgress\r\n      );\r\n    }\r\n    return true; // Indicates a change was made\r\n  }\r\n}\r\n\r\n// ================================================================================\r\n// Utility Functions\r\n// A collection of pure helper functions.\r\n// ================================================================================\r\ninterface RgbColor {\r\n  r: number;\r\n  g: number;\r\n  b: number;\r\n}\r\n\r\nconst ColorUtils = {\r\n  // A different implementation of hex-to-rgb conversion\r\n  hexToRgb(hex: string): RgbColor | null {\r\n    if (!hex || hex.charAt(0) !== \"#\") return null;\r\n    const cleanHex = hex.substring(1);\r\n\r\n    // Handle 3-digit hex\r\n    const fullHex =\r\n      cleanHex.length === 3\r\n        ? cleanHex\r\n            .split(\"\")\r\n            .map((c: string) => c + c)\r\n            .join(\"\")\r\n        : cleanHex;\r\n\r\n    if (fullHex.length !== 6) return null;\r\n\r\n    return {\r\n      r: parseInt(fullHex.substring(0, 2), 16),\r\n      g: parseInt(fullHex.substring(2, 4), 16),\r\n      b: parseInt(fullHex.substring(4, 6), 16),\r\n    };\r\n  },\r\n  // Interpolates between two RGB colors\r\n  interpolateRgb(start: RgbColor, end: RgbColor, factor: number): string {\r\n    const r = Math.round(start.r + (end.r - start.r) * factor);\r\n    const g = Math.round(start.g + (end.g - start.g) * factor);\r\n    const b = Math.round(start.b + (end.b - start.b) * factor);\r\n    return `rgb(${r}, ${g}, ${b})`;\r\n  },\r\n  // Picks a random color from the provided array\r\n  getRandomColor(colors: string[]): string {\r\n    return colors[Math.floor(Math.random() * colors.length)];\r\n  },\r\n};\r\n\r\ninterface AnimationOptions {\r\n  colors?: string[];\r\n  speed?: number;\r\n  smooth?: boolean;\r\n}\r\n\r\nconst useMatrixAnimation = (\r\n  canvasRef: React.RefObject<HTMLCanvasElement | null>,\r\n  options: AnimationOptions\r\n) => {\r\n  const {\r\n    colors = [\"#2b4539\", \"#61dca3\", \"#61b3dc\"],\r\n    speed = 50,\r\n    smooth = true,\r\n  } = options;\r\n\r\n  // Using refs to store animation state without causing re-renders\r\n  const particlesRef = useRef<Particle[]>([]);\r\n  const animationFrameId = useRef<number | null>(null);\r\n  const lastUpdateTime = useRef<number>(0);\r\n  const contextRef = useRef<CanvasRenderingContext2D | null>(null);\r\n\r\n  // Memoize the getRandomColor function to ensure stability\r\n  const getRandomColorMemoized = useCallback(\r\n    () => ColorUtils.getRandomColor(colors),\r\n    [colors]\r\n  );\r\n\r\n  useEffect(() => {\r\n    const canvas = canvasRef.current;\r\n    if (!canvas) return;\r\n\r\n    const context = canvas.getContext(\"2d\", { willReadFrequently: true });\r\n    if (!context) return;\r\n    contextRef.current = context;\r\n\r\n    const grid = { cols: 0, rows: 0 };\r\n\r\n    // This function initializes or re-initializes the particle grid\r\n    const setup = (width: number, height: number) => {\r\n      const dpr = window.devicePixelRatio || 1;\r\n      canvas.width = width * dpr;\r\n      canvas.height = height * dpr;\r\n      canvas.style.width = `${width}px`;\r\n      canvas.style.height = `${height}px`;\r\n      context.setTransform(dpr, 0, 0, dpr, 0, 0);\r\n\r\n      context.font = `${FONT_SIZE}px monospace`;\r\n      context.textBaseline = \"top\";\r\n\r\n      grid.cols = Math.ceil(width / CHAR_WIDTH);\r\n      grid.rows = Math.ceil(height / CHAR_HEIGHT);\r\n\r\n      particlesRef.current = [];\r\n      for (let row = 0; row < grid.rows; row++) {\r\n        for (let col = 0; col < grid.cols; col++) {\r\n          const x = col * CHAR_WIDTH;\r\n          const y = row * CHAR_HEIGHT;\r\n          const char =\r\n            CHARACTER_SET[Math.floor(Math.random() * CHARACTER_SET.length)];\r\n          const color = getRandomColorMemoized();\r\n          const targetColor = getRandomColorMemoized();\r\n          particlesRef.current.push(\r\n            new Particle(x, y, char, color, targetColor)\r\n          );\r\n        }\r\n      }\r\n    };\r\n\r\n    // The main animation loop\r\n    const animate = (timestamp: number) => {\r\n      let needsRedraw = false;\r\n      const elapsed = timestamp - lastUpdateTime.current;\r\n\r\n      // Update a batch of particles based on the speed setting\r\n      if (elapsed > speed) {\r\n        const updateCount = Math.max(\r\n          1,\r\n          Math.floor(particlesRef.current.length * 0.05)\r\n        );\r\n        for (let i = 0; i < updateCount; i++) {\r\n          const index = Math.floor(Math.random() * particlesRef.current.length);\r\n          const particle = particlesRef.current[index];\r\n          if (particle) {\r\n            particle.randomizeCharacter();\r\n            particle.setNewTargetColor(getRandomColorMemoized(), smooth);\r\n          }\r\n        }\r\n        lastUpdateTime.current = timestamp;\r\n        needsRedraw = true;\r\n      }\r\n\r\n      // Handle smooth color transitions for any active particles\r\n      if (smooth) {\r\n        particlesRef.current.forEach((p) => {\r\n          if (p.updateColorTransition()) {\r\n            needsRedraw = true;\r\n          }\r\n        });\r\n      }\r\n\r\n      // Only redraw the canvas if something has changed\r\n      if (needsRedraw) {\r\n        const canvasWidth = canvas.width / (window.devicePixelRatio || 1);\r\n        const canvasHeight = canvas.height / (window.devicePixelRatio || 1);\r\n        context.clearRect(0, 0, canvasWidth, canvasHeight);\r\n        particlesRef.current.forEach((p) => p.draw(context));\r\n      }\r\n\r\n      animationFrameId.current = requestAnimationFrame(animate);\r\n    };\r\n\r\n    // Use ResizeObserver for efficient resize handling\r\n    const resizeObserver = new ResizeObserver((entries) => {\r\n      if (!entries || entries.length === 0) return;\r\n      const { width, height } = entries[0].contentRect;\r\n      setup(width, height);\r\n    });\r\n\r\n    if (canvas.parentElement) {\r\n      resizeObserver.observe(canvas.parentElement);\r\n    }\r\n\r\n    // Start the animation\r\n    animate(0);\r\n\r\n    // Cleanup function to stop the animation and observer\r\n    return () => {\r\n      if (animationFrameId.current) {\r\n        cancelAnimationFrame(animationFrameId.current);\r\n      }\r\n      resizeObserver.disconnect();\r\n    };\r\n  }, [colors, speed, smooth, canvasRef, getRandomColorMemoized]); // Dependencies for the effect\r\n};\r\n\r\ninterface LetterGlitchProps {\r\n  glitchColors: string[];\r\n  glitchSpeed: number;\r\n  smooth: boolean;\r\n  centerVignette?: boolean;\r\n  outerVignette?: boolean;\r\n}\r\n\r\nconst LetterGlitch = ({\r\n  glitchColors,\r\n  glitchSpeed,\r\n  smooth,\r\n  centerVignette = false,\r\n  outerVignette = true,\r\n}: LetterGlitchProps) => {\r\n  const canvasRef = useRef<HTMLCanvasElement>(null);\r\n\r\n  // The custom hook handles all the complex animation logic\r\n  useMatrixAnimation(canvasRef, {\r\n    colors: glitchColors,\r\n    speed: glitchSpeed,\r\n    smooth: smooth,\r\n  });\r\n\r\n  return (\r\n    <div className=\"relative w-full h-full bg-black overflow-hidden\">\r\n      <canvas ref={canvasRef} className=\"block w-full h-full\" />\r\n      {/* Vignette overlays for visual effect */}\r\n      {outerVignette && (\r\n        <div className=\"absolute inset-0 pointer-events-none bg-[radial-gradient(circle,_rgba(0,0,0,0)_60%,_rgba(0,0,0,1)_100%)]\"></div>\r\n      )}\r\n      {centerVignette && (\r\n        <div className=\"absolute inset-0 pointer-events-none bg-[radial-gradient(circle,_rgba(0,0,0,0.8)_0%,_rgba(0,0,0,0)_60%)]\"></div>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\n// ================================================================================\r\n// Wrapper / Example Implementation\r\n// This component demonstrates how to use the MatrixRain component.\r\n// ================================================================================\r\nexport default function LetterGlitchWrapper() {\r\n  return (\r\n    <div className=\"w-full h-[400px]\">\r\n      <LetterGlitch\r\n        glitchColors={[\r\n          \"#32a852\", // green\r\n          \"#4287f5\", // blue\r\n          \"#d942f5\", // purple\r\n          \"#f54242\", // red\r\n          \"#f5e342\", // yellow\r\n          \"#42f5f5\", // cyan\r\n          \"#f5a142\", // orange\r\n        ]}\r\n        glitchSpeed={50}\r\n        smooth={true}\r\n        outerVignette={true}\r\n        centerVignette={false}\r\n      />\r\n    </div>\r\n  );\r\n}\r\n",
      "type": "registry:ui"
    }
  ]
}