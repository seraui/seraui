{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "glitchvault",
  "title": "Glitchvault",
  "description": "A minimalistic glitchvault component designed with React and Tailwind CSS.",
  "author": "Reche Soares",
  "type": "registry:ui",
  "dependencies": [],
  "devDependencies": [],
  "registryDependencies": [],
  "cssVars": {
    "dark": {},
    "light": {}
  },
  "files": [
    {
      "path": "glitchvault.tsx",
      "content": "import GlitchVault from \"./glitchvault\";\r\nexport default function GlitchVaultProfile() {\r\n  return (\r\n    <main className=\"w-full  flex flex-col items-center justify-center p-4 relative overflow-hidden\">\r\n      <div className=\"absolute inset-0\"></div>\r\n      <GlitchVault\r\n        className=\"w-full max-w-sm backdrop-blur-xl bg-white/20 dark:bg-black/20 border border-white/30 dark:border-white/10 rounded-2xl shadow-2xl shadow-cyan-500/10 relative z-10\"\r\n        glitchColor=\"#0AF0F0\"\r\n        glitchRadius={120}\r\n      >\r\n        <div className=\"p-8 text-center relative\">\r\n          <div className=\"absolute inset-0 bg-gradient-to-b from-transparent via-white/5 to-transparent rounded-2xl\"></div>\r\n          <div className=\"flex justify-center items-center mb-8 relative z-10\">\r\n            <div className=\"w-28 h-28 bg-gradient-to-br from-cyan-400/20 to-blue-500/20 backdrop-blur-sm rounded-full flex items-center justify-center border border-white/20 shadow-lg shadow-cyan-500/20 group cursor-pointer hover:scale-105 transition-all duration-500\">\r\n              <div className=\"w-24 h-24 bg-gradient-to-br from-cyan-500/10 to-blue-600/10 rounded-full flex items-center justify-center border border-white/10\">\r\n                <span className=\"text-cyan-600 dark:text-cyan-300 text-sm font-medium opacity-70 group-hover:opacity-100 group-hover:scale-110 transition-all duration-300\">\r\n                  Hover me\r\n                </span>\r\n              </div>\r\n            </div>\r\n          </div>\r\n          <h2 className=\"text-3xl font-bold bg-gradient-to-r from-slate-800 via-slate-700 to-cyan-700 dark:from-white dark:via-slate-100 dark:to-cyan-300 bg-clip-text text-transparent mb-2 tracking-wide relative z-10\">\r\n            Aura\r\n          </h2>\r\n          <p className=\"text-slate-600/80 dark:text-slate-300/80 mb-8 text-sm font-medium relative z-10\">\r\n            UI/UX Designer & Developer\r\n          </p>\r\n          <button className=\"bg-gradient-to-r from-cyan-500/10 via-blue-500/10 to-cyan-500/10 backdrop-blur-sm border border-cyan-400/30 text-cyan-700 dark:text-cyan-300 px-8 py-3 rounded-full hover:from-cyan-500/20 hover:via-blue-500/20 hover:to-cyan-500/20 hover:border-cyan-400/50 hover:shadow-lg hover:shadow-cyan-500/25 transition-all duration-300 font-medium relative z-10 hover:scale-105\">\r\n            View Profile\r\n          </button>\r\n        </div>\r\n      </GlitchVault>\r\n    </main>\r\n  );\r\n}\r\n",
      "type": "registry:ui"
    },
    {
      "path": "glitchvault-card.tsx",
      "content": "import GlitchVault from \"./glitchvault\";\r\n\r\nexport default function GlitchVaultCard() {\r\n  return (\r\n    <GlitchVault\r\n      className=\"w-full max-w-md border border-slate-200 dark:border-slate-800 rounded-xl bg-white/50 dark:bg-slate-900/50 backdrop-blur-sm\"\r\n      glitchColor=\"#FF6B6B\"\r\n      glitchRadius={80}\r\n    >\r\n      <div className=\"p-6\">\r\n        <div className=\"flex items-center gap-4 mb-4\">\r\n          <div className=\"w-12 h-12 bg-gradient-to-br from-red-400 to-pink-500 rounded-lg flex items-center justify-center\">\r\n            <span className=\"text-white font-bold text-lg\">ðŸš€</span>\r\n          </div>\r\n          <div>\r\n            <h3 className=\"font-semibold text-slate-800 dark:text-slate-100\">\r\n              Project Launch\r\n            </h3>\r\n            <p className=\"text-sm text-slate-600 dark:text-slate-400\">\r\n              Ready to deploy\r\n            </p>\r\n          </div>\r\n        </div>\r\n        <p className=\"text-slate-700 dark:text-slate-300 text-sm mb-4\">\r\n          Your application is ready for production deployment with all tests\r\n          passing.\r\n        </p>\r\n        <div className=\"flex gap-2\">\r\n          <button className=\"bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-lg text-sm font-medium transition-colors\">\r\n            Deploy Now\r\n          </button>\r\n          <button className=\"border border-slate-300 dark:border-slate-600 text-slate-700 dark:text-slate-300 px-4 py-2 rounded-lg text-sm font-medium hover:bg-slate-50 dark:hover:bg-slate-800 transition-colors\">\r\n            View Details\r\n          </button>\r\n        </div>\r\n      </div>\r\n    </GlitchVault>\r\n  );\r\n}\r\n",
      "type": "registry:ui"
    },
    {
      "path": "glitchvault.tsx",
      "content": "\"use client\";\r\nimport React, { useRef, useEffect, useCallback, useMemo } from \"react\";\r\n\r\n// Type declarations for OffscreenCanvas (may not be available in all environments)\r\ndeclare global {\r\n  interface Window {\r\n    OffscreenCanvas?: {\r\n      new (width: number, height: number): OffscreenCanvas;\r\n    };\r\n  }\r\n}\r\n\r\ninterface OffscreenCanvas {\r\n  width: number;\r\n  height: number;\r\n  getContext(\r\n    contextId: \"2d\",\r\n    options?: CanvasRenderingContext2DSettings\r\n  ): OffscreenCanvasRenderingContext2D | null;\r\n}\r\n\r\ninterface OffscreenCanvasRenderingContext2D {\r\n  canvas: OffscreenCanvas;\r\n  clearRect(x: number, y: number, w: number, h: number): void;\r\n  fillText(text: string, x: number, y: number): void;\r\n  createRadialGradient(\r\n    x0: number,\r\n    y0: number,\r\n    r0: number,\r\n    x1: number,\r\n    y1: number,\r\n    r1: number\r\n  ): CanvasGradient;\r\n  font: string;\r\n  textBaseline: CanvasTextBaseline;\r\n  fillStyle: string | CanvasGradient | CanvasPattern;\r\n  globalAlpha: number;\r\n}\r\n\r\ninterface HexColor {\r\n  r: number;\r\n  g: number;\r\n  b: number;\r\n}\r\n\r\ninterface MousePosition {\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\ninterface GridDimensions {\r\n  cols: number;\r\n  rows: number;\r\n}\r\n\r\ninterface MatrixAnimationOptions {\r\n  glitchColor?: string;\r\n  glitchRadius?: number;\r\n  performanceMode?: \"high\" | \"balanced\" | \"low\";\r\n}\r\n\r\ninterface LetterGlitchProps {\r\n  glitchColor?: string;\r\n  glitchRadius?: number;\r\n  interactionRef: React.RefObject<HTMLDivElement | null>;\r\n  performanceMode?: \"high\" | \"balanced\" | \"low\";\r\n}\r\n\r\ninterface GlitchVaultProps {\r\n  children: React.ReactNode;\r\n  className?: string;\r\n  glitchColor?: string;\r\n  glitchRadius?: number;\r\n  performanceMode?: \"high\" | \"balanced\" | \"low\";\r\n  disabled?: boolean;\r\n  theme?: \"light\" | \"dark\" | \"auto\";\r\n}\r\n\r\nconst FONT_SIZE = 16;\r\nconst CHAR_WIDTH = 10;\r\nconst CHAR_HEIGHT = 20;\r\nconst CHARACTER_SET =\r\n  \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%&*()-_{}[]:;<>,.?/\";\r\nconst PARTICLE_POOL_SIZE = 5000; // Pre-allocate particles\r\nconst RENDER_THROTTLE = 16; // Throttle rendering to ~60fps\r\n\r\n// Theme-specific color\r\n\r\nfunction hexToRgb(hex: string): HexColor | null {\r\n  if (!hex) return null;\r\n  const shorthandRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\r\n  hex = hex.replace(\r\n    shorthandRegex,\r\n    (_: string, r: string, g: string, b: string) => r + r + g + g + b + b\r\n  );\r\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\r\n  return result\r\n    ? {\r\n        r: parseInt(result[1], 16),\r\n        g: parseInt(result[2], 16),\r\n        b: parseInt(result[3], 16),\r\n      }\r\n    : null;\r\n}\r\n\r\nclass Particle {\r\n  x = 0;\r\n  y = 0;\r\n  char = \"\";\r\n  opacity = 0;\r\n  targetOpacity = 0;\r\n  opacityVelocity = 0;\r\n  lastUpdate = 0;\r\n  isActive = false;\r\n  isDirty = false;\r\n\r\n  reset(x: number, y: number, char: string): void {\r\n    this.x = x;\r\n    this.y = y;\r\n    this.char = char;\r\n    this.opacity = 0;\r\n    this.targetOpacity = 0;\r\n    this.opacityVelocity = 0;\r\n    this.lastUpdate = performance.now();\r\n    this.isActive = true;\r\n    this.isDirty = false;\r\n  }\r\n\r\n  update(deltaTime: number): boolean {\r\n    if (!this.isActive || Math.abs(this.opacity - this.targetOpacity) < 0.01) {\r\n      if (this.opacity !== this.targetOpacity) {\r\n        this.opacity = this.targetOpacity;\r\n      }\r\n      return false;\r\n    }\r\n\r\n    const diff = this.targetOpacity - this.opacity;\r\n    this.opacityVelocity = diff * 0.15; // Smooth easing\r\n    this.opacity += this.opacityVelocity * (deltaTime / 16);\r\n\r\n    if (Math.abs(this.opacity - this.targetOpacity) < 0.01) {\r\n      this.opacity = this.targetOpacity;\r\n    }\r\n\r\n    this.isDirty = true;\r\n    return true;\r\n  }\r\n\r\n  setTargetOpacity(target: number): void {\r\n    if (this.targetOpacity !== target) {\r\n      this.targetOpacity = target;\r\n      if (target > 0 && this.opacity === 0) {\r\n        this.randomizeCharacter();\r\n      }\r\n    }\r\n  }\r\n\r\n  randomizeCharacter(): void {\r\n    this.char = CHARACTER_SET[Math.floor(Math.random() * CHARACTER_SET.length)];\r\n    this.isDirty = true;\r\n  }\r\n}\r\n\r\nclass ParticlePool {\r\n  pool: Particle[] = [];\r\n  activeParticles = new Set<Particle>();\r\n\r\n  constructor(size: number) {\r\n    for (let i = 0; i < size; i++) {\r\n      this.pool.push(new Particle());\r\n    }\r\n  }\r\n\r\n  acquire(x: number, y: number, char: string): Particle | null {\r\n    const particle = this.pool.pop();\r\n    if (particle) {\r\n      particle.reset(x, y, char);\r\n      this.activeParticles.add(particle);\r\n      return particle;\r\n    }\r\n    // console.warn(\"Particle pool depleted.\");\r\n    return null;\r\n  }\r\n\r\n  release(particle: Particle): void {\r\n    particle.isActive = false;\r\n    this.activeParticles.delete(particle);\r\n    this.pool.push(particle);\r\n  }\r\n\r\n  getActiveParticles(): Particle[] {\r\n    return Array.from(this.activeParticles);\r\n  }\r\n\r\n  clear(): void {\r\n    this.activeParticles.forEach((p) => this.release(p));\r\n  }\r\n}\r\n\r\nclass RenderingEngine {\r\n  ctx: CanvasRenderingContext2D;\r\n  offscreenCanvas: OffscreenCanvas | null = null;\r\n  offscreenCtx: OffscreenCanvasRenderingContext2D | null = null;\r\n  lastRenderTime = 0;\r\n  renderThrottle: number;\r\n\r\n  constructor(ctx: CanvasRenderingContext2D, throttle = RENDER_THROTTLE) {\r\n    this.ctx = ctx;\r\n    this.renderThrottle = throttle;\r\n    this.setupOffscreenCanvas();\r\n  }\r\n\r\n  setupOffscreenCanvas(): void {\r\n    if (typeof window !== \"undefined\" && window.OffscreenCanvas) {\r\n      this.offscreenCanvas = new window.OffscreenCanvas(\r\n        this.ctx.canvas.width,\r\n        this.ctx.canvas.height\r\n      );\r\n      this.offscreenCtx = this.offscreenCanvas.getContext(\"2d\", {\r\n        alpha: true,\r\n        desynchronized: true,\r\n      });\r\n\r\n      if (this.offscreenCtx) {\r\n        this.offscreenCtx.font = `${FONT_SIZE}px monospace`;\r\n        this.offscreenCtx.textBaseline = \"top\";\r\n      }\r\n    }\r\n  }\r\n\r\n  render(\r\n    particles: Particle[],\r\n    glitchColor: string,\r\n    forceRender = false\r\n  ): void {\r\n    const now = performance.now();\r\n    if (!forceRender && now - this.lastRenderTime < this.renderThrottle) {\r\n      return;\r\n    }\r\n\r\n    this.lastRenderTime = now;\r\n    const renderCtx = this.offscreenCtx || this.ctx;\r\n    const baseColor = hexToRgb(glitchColor);\r\n    if (!baseColor) return; // Exit if the color is invalid\r\n\r\n    renderCtx.clearRect(0, 0, renderCtx.canvas.width, renderCtx.canvas.height);\r\n\r\n    const opacityBuckets = new Map<number, Particle[]>();\r\n\r\n    particles.forEach((particle) => {\r\n      if (particle.opacity > 0.01) {\r\n        const bucketKey = Math.round(particle.opacity * 20) / 20; // Group in 5% increments\r\n        if (!opacityBuckets.has(bucketKey)) {\r\n          opacityBuckets.set(bucketKey, []);\r\n        }\r\n        opacityBuckets.get(bucketKey)!.push(particle);\r\n      }\r\n    });\r\n\r\n    opacityBuckets.forEach((bucket, opacity) => {\r\n      renderCtx.globalAlpha = opacity;\r\n\r\n      bucket.forEach((particle) => {\r\n        const gradient = renderCtx.createRadialGradient(\r\n          particle.x + CHAR_WIDTH / 2,\r\n          particle.y + CHAR_HEIGHT / 2,\r\n          0,\r\n          particle.x + CHAR_WIDTH / 2,\r\n          particle.y + CHAR_HEIGHT / 2,\r\n          CHAR_WIDTH * 1.5\r\n        );\r\n\r\n        gradient.addColorStop(\r\n          0,\r\n          `rgba(${baseColor.r}, ${baseColor.g}, ${baseColor.b}, 1)`\r\n        );\r\n        gradient.addColorStop(\r\n          0.5,\r\n          `rgba(${baseColor.r}, ${baseColor.g}, ${baseColor.b}, 0.5)`\r\n        );\r\n        gradient.addColorStop(\r\n          1,\r\n          `rgba(${baseColor.r}, ${baseColor.g}, ${baseColor.b}, 0)`\r\n        );\r\n\r\n        renderCtx.fillStyle = gradient;\r\n        renderCtx.fillText(particle.char, particle.x, particle.y);\r\n      });\r\n    });\r\n\r\n    if (this.offscreenCanvas && this.offscreenCtx) {\r\n      this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\r\n      this.ctx.drawImage(\r\n        this.offscreenCanvas as unknown as CanvasImageSource,\r\n        0,\r\n        0\r\n      );\r\n    }\r\n  }\r\n\r\n  resize(width: number, height: number): void {\r\n    if (this.offscreenCanvas) {\r\n      this.offscreenCanvas.width = width;\r\n      this.offscreenCanvas.height = height;\r\n      if (this.offscreenCtx) {\r\n        this.offscreenCtx.font = `${FONT_SIZE}px monospace`;\r\n        this.offscreenCtx.textBaseline = \"top\";\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nconst useMatrixAnimation = (\r\n  canvasRef: React.RefObject<HTMLCanvasElement | null>,\r\n  interactionRef: React.RefObject<HTMLDivElement | null>,\r\n  options: MatrixAnimationOptions\r\n) => {\r\n  const {\r\n    glitchColor = \"#00ffff\",\r\n    glitchRadius = 100,\r\n    performanceMode = \"balanced\",\r\n  } = options;\r\n\r\n  const particlePoolRef = useRef<ParticlePool | null>(null);\r\n  const renderingEngineRef = useRef<RenderingEngine | null>(null);\r\n  const animationFrameId = useRef<number | null>(null);\r\n  const mousePosRef = useRef<MousePosition | null>(null);\r\n  const lastFrameTime = useRef(0);\r\n  const gridRef = useRef<GridDimensions>({\r\n    cols: 0,\r\n    rows: 0,\r\n  });\r\n\r\n  const performanceSettings = useMemo(() => {\r\n    switch (performanceMode) {\r\n      case \"high\":\r\n        return {\r\n          updateInterval: 16,\r\n          renderThrottle: 16,\r\n          batchSize: 200,\r\n        };\r\n      case \"low\":\r\n        return {\r\n          updateInterval: 50,\r\n          renderThrottle: 33,\r\n          batchSize: 50,\r\n        };\r\n      default:\r\n        return {\r\n          updateInterval: 33,\r\n          renderThrottle: 16,\r\n          batchSize: 100,\r\n        };\r\n    }\r\n  }, [performanceMode]);\r\n\r\n  const handleMouseMove = useCallback(\r\n    (event: Event) => {\r\n      const mouseEvent = event as MouseEvent;\r\n      const interactionElement = interactionRef?.current;\r\n      if (!interactionElement) return;\r\n\r\n      const rect = interactionElement.getBoundingClientRect();\r\n      mousePosRef.current = {\r\n        x: mouseEvent.clientX - rect.left,\r\n        y: mouseEvent.clientY - rect.top,\r\n      };\r\n    },\r\n    [interactionRef]\r\n  );\r\n\r\n  const handleMouseLeave = useCallback(() => {\r\n    mousePosRef.current = null;\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    const canvas = canvasRef.current;\r\n    const interactionElement = interactionRef?.current || canvas;\r\n    if (!canvas || !interactionElement) return;\r\n\r\n    const context = canvas.getContext(\"2d\", {\r\n      alpha: true,\r\n      desynchronized: true,\r\n      willReadFrequently: false,\r\n    });\r\n    if (!context) return;\r\n\r\n    particlePoolRef.current = new ParticlePool(PARTICLE_POOL_SIZE);\r\n    renderingEngineRef.current = new RenderingEngine(\r\n      context,\r\n      performanceSettings.renderThrottle\r\n    );\r\n\r\n    const setup = (width: number, height: number) => {\r\n      const dpr = window.devicePixelRatio || 1;\r\n      canvas.width = width * dpr;\r\n      canvas.height = height * dpr;\r\n      canvas.style.width = `${width}px`;\r\n      canvas.style.height = `${height}px`;\r\n      context.setTransform(dpr, 0, 0, dpr, 0, 0);\r\n\r\n      context.font = `${FONT_SIZE}px monospace`;\r\n      context.textBaseline = \"top\";\r\n\r\n      gridRef.current.cols = Math.ceil(width / CHAR_WIDTH);\r\n      gridRef.current.rows = Math.ceil(height / CHAR_HEIGHT);\r\n\r\n      particlePoolRef.current?.clear();\r\n\r\n      for (let row = 0; row < gridRef.current.rows; row++) {\r\n        for (let col = 0; col < gridRef.current.cols; col++) {\r\n          const x = col * CHAR_WIDTH;\r\n          const y = row * CHAR_HEIGHT;\r\n          const char =\r\n            CHARACTER_SET[Math.floor(Math.random() * CHARACTER_SET.length)];\r\n          particlePoolRef.current?.acquire(x, y, char);\r\n        }\r\n      }\r\n\r\n      renderingEngineRef.current?.resize(canvas.width, canvas.height);\r\n    };\r\n\r\n    const animate = (currentTime: number) => {\r\n      const deltaTime = currentTime - lastFrameTime.current;\r\n\r\n      if (deltaTime >= performanceSettings.updateInterval) {\r\n        const particles = particlePoolRef.current?.getActiveParticles() || [];\r\n        const mousePos = mousePosRef.current;\r\n        let needsRender = false;\r\n\r\n        for (\r\n          let i = 0;\r\n          i < particles.length;\r\n          i += performanceSettings.batchSize\r\n        ) {\r\n          const batch = particles.slice(i, i + performanceSettings.batchSize);\r\n\r\n          batch.forEach((particle) => {\r\n            let targetOpacity = 0;\r\n\r\n            if (mousePos) {\r\n              const dx = particle.x - mousePos.x + CHAR_WIDTH / 2;\r\n              const dy = particle.y - mousePos.y + CHAR_HEIGHT / 2;\r\n              const distance = Math.sqrt(dx * dx + dy * dy);\r\n\r\n              if (distance < glitchRadius) {\r\n                targetOpacity = 1 - distance / glitchRadius;\r\n              }\r\n            }\r\n\r\n            particle.setTargetOpacity(targetOpacity);\r\n            if (particle.update(deltaTime)) {\r\n              needsRender = true;\r\n            }\r\n          });\r\n        }\r\n\r\n        if (needsRender && renderingEngineRef.current) {\r\n          renderingEngineRef.current.render(particles, glitchColor);\r\n        }\r\n\r\n        lastFrameTime.current = currentTime;\r\n      }\r\n\r\n      animationFrameId.current = requestAnimationFrame(animate);\r\n    };\r\n\r\n    interactionElement.addEventListener(\"mousemove\", handleMouseMove, {\r\n      passive: true,\r\n    });\r\n    interactionElement.addEventListener(\"mouseleave\", handleMouseLeave, {\r\n      passive: true,\r\n    });\r\n\r\n    const resizeObserver = new ResizeObserver((entries) => {\r\n      if (!entries || entries.length === 0) return;\r\n      const { width, height } = entries[0].contentRect;\r\n      setup(width, height);\r\n    });\r\n\r\n    if (canvas.parentElement) {\r\n      resizeObserver.observe(canvas.parentElement);\r\n    }\r\n\r\n    lastFrameTime.current = performance.now();\r\n    animate(lastFrameTime.current);\r\n\r\n    return () => {\r\n      interactionElement.removeEventListener(\"mousemove\", handleMouseMove);\r\n      interactionElement.removeEventListener(\"mouseleave\", handleMouseLeave);\r\n      if (animationFrameId.current) {\r\n        cancelAnimationFrame(animationFrameId.current);\r\n      }\r\n      resizeObserver.disconnect();\r\n      particlePoolRef.current?.clear();\r\n    };\r\n  }, [\r\n    glitchColor,\r\n    glitchRadius,\r\n    handleMouseMove,\r\n    handleMouseLeave,\r\n    canvasRef,\r\n    interactionRef,\r\n    performanceSettings,\r\n  ]);\r\n};\r\n\r\nconst LetterGlitch = React.memo<LetterGlitchProps>(\r\n  ({\r\n    glitchColor,\r\n    glitchRadius,\r\n    interactionRef,\r\n    performanceMode = \"balanced\",\r\n  }) => {\r\n    const canvasRef = useRef<HTMLCanvasElement>(null);\r\n\r\n    useMatrixAnimation(canvasRef, interactionRef, {\r\n      glitchColor,\r\n      glitchRadius,\r\n      performanceMode,\r\n    });\r\n\r\n    return <canvas ref={canvasRef} className=\"block w-full h-full\" />;\r\n  }\r\n);\r\n\r\nLetterGlitch.displayName = \"LetterGlitch\";\r\n\r\nconst GlitchVault = React.memo<GlitchVaultProps>(\r\n  ({\r\n    children,\r\n    className,\r\n    glitchColor = \"#0AF0F0\",\r\n    glitchRadius = 120,\r\n    performanceMode = \"balanced\",\r\n    disabled = false,\r\n  }) => {\r\n    const interactionRef = useRef<HTMLDivElement>(null);\r\n\r\n    return (\r\n      <div\r\n        ref={interactionRef}\r\n        className={`relative rounded-2xl overflow-hidden ${className}`}\r\n      >\r\n        {!disabled && (\r\n          <div className=\"absolute inset-0 z-0\">\r\n            <LetterGlitch\r\n              interactionRef={interactionRef}\r\n              glitchColor={glitchColor}\r\n              glitchRadius={glitchRadius}\r\n              performanceMode={performanceMode}\r\n            />\r\n          </div>\r\n        )}\r\n        <div className=\"relative z-20\"> {children} </div>\r\n      </div>\r\n    );\r\n  }\r\n);\r\nGlitchVault.displayName = \"GlitchVault\";\r\nexport default GlitchVault;\r\n",
      "type": "registry:ui"
    }
  ]
}